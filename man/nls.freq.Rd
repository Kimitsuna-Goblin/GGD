% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ggd.nls.freq.R
\name{nls.freq}
\alias{nls.freq}
\alias{ggd.nls.freq}
\alias{\S4method{nls.freq}{GGD}}
\title{Approximating a frequency distribution}
\usage{
ggd.nls.freq(data, x = "x", freq = "freq", total = NULL,
         kind = NULL, mix.type = NULL,
         grad = c("default", "normal", "h", "v", "v2", "v3", "hv"),
         custom.d = NULL, ncmp = 0,
         eq.mean = logical(), eq.sd = logical(),
         start.level = 100, start = NULL, control = list(),
         not.use.nls = FALSE, cor.method = NULL, ...)

\S4method{nls.freq}{GGD}(data, x = "x", freq = "freq", total = NULL,
         this.kind = NULL, this.mix.type = NULL,
         grad = c("default", "normal", "h", "v", "v2", "v3", "hv"),
         this.custom.d = NULL, ncmp = nrow(cmp),
         eq.mean = logical(), eq.sd = logical(),
         start.level = 100, start = NULL, control = list(),
         not.use.nls = FALSE, cor.method = NULL, ...)
}
\arguments{
\item{data}{A data frame which represents the frequency distribution.
                     It must contain at least 2 numeric columns for \code{x} and \code{freq}.

                     Column \bold{\code{x}} is for the x-coordinates.
                     Each value is expected to be a numeric value which represents a cell of
                     the frequency distribution
                     as the x-coordinate at the center of the cell.
                     The values must be arranged in ascending order, and not be duplicated.

                     Column \bold{\code{freq}} is for the frequencies following \code{x}.
                     The values of frequencies should not be negative.
                     Both integers and real numbers are allowed for the values.

                     Rows which contain \code{NA} or \code{NaN} for \code{x} or \code{freq}
                     are ignored. The number of rows should be large enough;
                     it is recommended that there are more than 8 valid rows.
                     At least, 3 valid rows must be contained.

                     Column names and column numbers for \code{x} and \code{freq}
                     are flexible. You can indicate them with next two arguments.}

\item{x}{The column name or column number for x-coordinates in \code{data}.}

\item{freq}{The column name or column number for frequencies in \code{data}.}

\item{total}{Total value of the frequencies.

                     If \code{NULL} (the default),
                     the total of \code{freq}, i.e., \code{\link[base]{sum}(data[[freq]])}
                     (on \code{\link[stats]{complete.cases}} of \code{x} and \code{freq})
                     is used for it.}

\item{kind}{A character string or a numeric value or a \code{\link[ggd]{GGD}} object
                     which indicates the kind of distribution model to be generated.
                     The matching method of \code{kind} follows that of
                     \code{objs} argument of \code{\link[ggd]{ggd.kind.index}}.

                     This argument gives the conditions of
                     the value of \code{mix.type} field,
                     and of whether the mean values or standard deviations of the components
                     should be aligned to the same value or not.

                     Indicating \code{mix.type} or \code{grad} other than \code{"default"},
                     or \code{eq.mean} and \code{eq.sd} other than \code{logical(0)}
                     can overwrite the condition of this argument.}

\item{mix.type}{A numeric value to set into \code{mix.type} field of
                     the \code{\link[ggd]{GGD}} object as an integer.
                     It should be an integer from \code{0} to \code{4} or \code{NULL}.

                     The type of the distribution model will be as:
                     \itemize{
                         \item 0: Normal distribution.
                         \item 1: Mean of 2 normal distributions.
                         \item 2: Horizontal gradation of 2 normal distributions.
                         \item 3: Vertical gradation of 2 or 3 normal distributions.
                                  The 2-component model has priority.
                         \item 4: Horizontal-Vertical gradation
                                  with 4 (2x2) normal distributions.
                     }

                     If other than \code{"default"} for \code{grad} argument is indicated,
                     this argument will be ignored.}

\item{grad}{A character string indicating the method of gradation.

                     \code{"h"} for horizontal, \code{"v"} for vertical,
                     and \code{"hv"} for horizontal-vertical.
                     The number after \code{"v"} is the number of components.
                     Numberless \code{"v"} is an alias for \code{"v2"}.

                     \code{"normal"} is for a normal distribution.
                     \code{"default"} is for depending on values of other arguments.

                     If other than \code{"default"} is indicated,
                     this function will create a \code{\link[ggd]{GGD}} object
                     according to this argument with ignoring \code{[this.]mix.type} argument
                     and overwriting the type indicated by \code{[this.]kind} argument.}

\item{custom.d}{A function for the density function of the custom distribution.

                     If \code{NULL}, the default function will be used with some warnings
                     when approximating with a custom distribution.

                     See \code{\link[ggd]{set.cmp}} for more information.}

\item{ncmp}{Number of components in \code{cmp} field.

                     This argument works only when using a custom distribution.
                     For other than custom distribution, the number of components is
                     determined according to the distribution model.

                     For \code{ggd.nls.freq} function,
                     a positive integer must be indicated when using a custom distribution.

                     For \code{nls.freq} method,
                     The number of rows in \code{cmp} field is used by default.
                     If another value is indicated, the value will be used instead.}

\item{eq.mean}{A logical. If \code{TRUE}, all of the mean values of of the components
                     are forced to be equal.

                     If \code{FALSE} or \code{logical(0)},
                     the mean values are not bound,
                     and mean-equaled components will be rarely constructed.

                     \code{TRUE} and \code{FALSE} can overwrite the condition indicated by
                     \code{kind} or \code{this.kind} argument.}

\item{eq.sd}{A logical. If \code{TRUE}, all of the standard deviations of
                     the components are forced to be equal.

                     If \code{FALSE} or \code{logical(0)},
                     the standard deviations are not bound,
                     and sigma-equaled components will be rarely constructed.

                     If both \code{eq.mean} and \code{eq.sd} are \code{TRUE},
                     a normal distribution will be constructed.

                     \code{TRUE} and \code{FALSE} can overwrite the condition indicated by
                     \code{kind} or \code{this.kind} argument.}

\item{start.level}{A numeric value of integer in from \code{0} to \code{3} or \code{100}
                     with default \code{100}; the level of guessing the initial values
                     for \code{start} argument of \code{\link[stats]{nls}}.

         Details for the levels are as:
         \itemize{
             \item \code{0}:
                      The mean and the standard deviation of the frequency distribution
                      are used as the initial values.
             \item \code{1}:
                      In addition to level \code{0}, it computes the local mean values
                      and local standard deviations of the frequency distribution
                      in ranges of x-coordinates where the effect of each of components is
                      likely to be heavy, and uses them for guessing the initial values
                      if they are likely to be better guesses.
             \item \code{2}:
                      In addition to level \code{0}, at first it computes some quantiles
                      from the frequency distribution, then it finds normal distributions
                      tracing two of the quantiles, and uses the mean values and
                      standard deviations of them for guessing the initial values
                      if they are likely to be better guesses.
             \item \code{3}:
                      It generates a \code{\link[ggd]{GGD}} object tracing
                      some (2, 3 or 5) quantiles computed from the frequency distribution,
                      and uses the mean values and standard deviations of the components
                      of the object as the initial values.
                      If the generating fails, level \code{2} is used instead.
             \item \code{100}:
                      Try all of above levels and adopt the result of the highest
                      \code{\link[stats]{cor}} value.
         }

         As the level increases within the range of \code{0} to \code{3},
         the initial model will tend to be closer to the frequency distribution.
         However, the accuracy of the result may not along with the level.
         It is possible that \code{\link[stats]{nls}} will succeed at level \code{1}
         and fail at level \code{3} for the same data.}

\item{start}{A list for \code{start} argument of \code{\link[stats]{nls}}.

                     You can provide your own \code{start} for \code{\link[stats]{nls}},
                     the mean values
                     (names are like: \code{mean}, \code{mean.i} or \code{mean.i.j})
                     and the \bold{square root} of the standard deviations
                     (names are like: \code{sqrt.sd}, \code{sqrt.sd.i} or \code{sqrt.sd.i.j})
                     of the normal distributions of the components.

                     Depending on the kind of the distribution model,
                     the name of the parameters are different.
                     You can use \code{\link[ggd]{ggd.start.template}}
                     to get the template of the list and know the names of the parameters.

                     If a not-\code{NULL} list is indicated for this argument,
                     \code{start.level} argument is ignored.}

\item{control}{The list for \code{control} argument of \code{\link[stats]{nls}}.
See \code{\link[stats]{nls.control}} for more information.}

\item{not.use.nls}{A logical.
                     If \code{TRUE}, this function does not use \code{\link[stats]{nls}} and
                     it outputs an object having the initial values in \code{cmp} field
                     as the result.
                     If \code{FALSE}, this function uses \code{\link[stats]{nls}}.

                     This argument works when \code{start.level} argument is
                     other than \code{100}. A warning will occur if \code{TRUE}
                     when \code{start.level} is \code{100}.

                     You can use \code{not.use.nls = TRUE} to check
                     whether the initial values are appropriate
                     when you have obtained an undesirable result from this function.}

\item{cor.method}{The \code{method} argument for \code{\link[stats]{cor}}.
It is a character string indicating which correlation coefficient
(or covariance) is to be computed in order to compare the results
between levels when \code{start.level = 100}.
If \code{NULL}, it uses the default method of \code{\link[stats]{cor}}.
This argument works only if \code{start.level = 100}.
See \code{\link[stats]{cor}} for more information.}

\item{...}{Each argument for \code{\link[stats]{nls}} can be indicated.
See "Arguments" of \code{\link[stats]{nls}} for more information.}

\item{this.kind}{A character string or a numeric value or a \code{\link[ggd]{GGD}} object
                     which indicates the kind of distribution model to be constructed.
                     It is equivalent to \code{kind} argument for \code{ggd.nls.freq}.

                     When this method is called without \code{this.kind} argument
                     or other conditions, it attempt to retain the value of
                     \code{mix.type} field as much as possible except for \code{kind} field,
                     i.e., the condition whether the mean value and standard deviation of
                     each component are aligned to same values or not may not be retained.
                     If you want to retain these conditions as well,
                     indicate the object itself to \code{this.kind} argument like as
                     \code{obj$nls.freq(data, this.kind = obj)}.}

\item{this.mix.type}{A numeric value to set into \code{mix.type} field as an integer.
                         It is equivalent to \code{mix.type} argument for
                         \code{ggd.nls.freq}.

                     If both of \code{this.kind} and \code{this.mix.type} are not given
                     and \code{grad} argument is \code{"default"},
                     the current value of \code{mix.type} field will be retained,
                     and number of components will also.
                     However, if the object has been cleared when this method is called,
                     \code{mix.type} field will be \code{2}, the initial value.}

\item{this.custom.d}{A function for the density function of the custom distribution.
                         It is equivalent to \code{custom.d} argument for
                         \code{ggd.nls.freq}.

                     If \code{NULL}, the current function in \code{custom.d} field
                     will be used when approximating with a custom distribution.

                     See \code{\link[ggd]{set.cmp}} for more information.}
}
\value{
A list containing components (invisible for \code{GGD} method)
         \item{obj}{
                 Generated \code{\link[ggd]{GGD}} object which most (at least locally)
                 closely approximates the given frequency distribution.
                 If \code{\link[stats]{nls}} has failed, it will be a cleared object.
                 For \code{\link[ggd]{GGD}} method,
                 the \code{\link[ggd]{GGD}} object itself.}
         \item{nls.out}{
                 The list of the output of \code{\link[stats]{nls}}.
                 If \code{\link[stats]{nls}} has not been used, \code{NULL} will be set.
                 See "Value" of \code{\link[stats]{nls}} for more information.}
         \item{start.level}{
                 The initial guessing level which is used actually to gain \code{obj}.
                 If \code{start.level = 100} is indicated,
                 the level for the best result will be set.
                 When \code{start.level = 3} is indicated
                 and if initial guessing has failed, \code{2} will be set.
                 If a not-\code{NULL} \code{start} argument is indicated,
                 \code{NA} will be set.}
         \item{start}{
                 The used \code{start} argument of \code{\link[stats]{nls}}.}
         \item{start.obj}{
                 A \code{\link[ggd]{GGD}} object corresponding to the initial values.
                 That is, a \code{\link[ggd]{GGD}} object in which
                 values of the above \code{start} are set directly to \code{cmp} field.}
         \item{cor}{
                 The vector of the correlation coefficient of between the result for
                 each initial guessing level in the range of \code{0} to \code{3}
                 and the frequency distribution.
                 This component is given only if \code{start.level = 100}.}
         \item{errors}{
                 A list of information about errors occurred in \code{\link[stats]{nls}}.
                 This component is given only if \code{start.level = 100}.
                 Each element in the list contains:
                 \itemize{
                     \item level: The initial guessing level when the error has occurred.
                     \item message: The error message.
                 }}
         \item{warnings}{
                 A list of information about warnings occurred in \code{\link[stats]{nls}}.
                 This component is given only if \code{start.level = 100}.
                 The composition of each element is same as \code{errors}.}

         For \code{GGD} method: If an error occurs, all fields of the object will be cleared
                                in most cases.
}
\description{
With the non-linear least squares (\code{\link[stats]{nls}}),
constructs a \code{\link[ggd]{GGD}} object which (locally) most closely approximates
the given frequency distribution.
Then \code{ggd.nls.freq} function generates a \code{\link[ggd]{GGD}} object,
and \code{nls.freq} method sets the fields according to the result.
"Locally" means that if the start value is modified, more closely approximating model
may be constructed.
The outliers of the frequency distribution will not be excluded in this function.
If necessary, outliers should be excluded by preprocessing.
}
\details{
\subsection{Why the standard deviations for "start" are square-rooted?}{
     You know a standard deviation must be a positive value.
     But if you use standard deviations directly in the formula for \code{\link[stats]{nls}},
     they sometimes drop into negative values while the Gauss-Newton algorithm is running
     and the algorithm will fail, even if it can reach convergence if done better.

     Therefore, to avoid such failures, we use square roots of standard deviations and
     take squares of them in the formula for \code{\link[stats]{nls}}.
 }
}
\examples{
 ## Preparing
 df <- data.frame(
             x      = seq( -2, 2, 0.2 ),
             freq   = c( 1517,  2292,  2513,  2763,  3724,  4046,  4713,
                         7947, 10997, 11824, 11133,  7868,  4692,  4103,
                         3698,  2740,  2549,  2284,  1499,  1147,   918 ),
             x.2    = seq( -20, 20, 2 ),
             freq.2 = c( .000974, .003797, .008523, .023142, .045017, .081743, .120990,
                         .142527, .124627, .106294, .078625, .059378, .045690, .042958,
                         .035760, .030938, .015675, .012516, .008139, .005114, .003582 ) )

 plot.freq.and.d <- function( obj, x, freq )
 {
     xlim <- c( min( x ), max( x ) )
     ylim <- c( 0, max( ggd:::get.d.freq( x, freq ) ) * 1.2 )
     plot( x, ggd:::get.d.freq( x, freq ), xlim = xlim, ylim = ylim, xlab = "", ylab = "" )
     par( new = TRUE )
     plot( seq( min( x ), max( x ), 0.01 ), obj$d( seq( min( x ), max( x ), 0.01 ) ),
           type = "l", xlim = xlim, ylim = ylim )
 }

 ## Examples
 result <- ggd.nls.freq( df, mix.type = 0 )
 result
 plot.freq.and.d( result$obj, df$x, df$freq )

 ## "start.level" can be omitted, but it is indicated here for processing speeds.
 a <- GGD$new()
 a$nls.freq( df, this.kind = "2.*Sigma-Equaled Vertical", start.level = 2 )
 a

 ## "Sigma-Differed" is overwritten with "eq.sd = FALSE" after "kind = a"
 b <- ggd.nls.freq( df, kind = a, eq.sd = FALSE, start.level = 2 )$obj
 a$kind; b$kind      ## "... Sigma-Equaled ..."; "... Sigma-Differed ..."
 plot.freq.and.d( a, df$x, df$freq )
 plot.freq.and.d( b, df$x, df$freq )

 ## You can set start parameters with "start" argument.
 start.list <- ggd.start.template( 14 )
 start.list

 start.list$mean.1.1 <- -0.671
 start.list$mean.1.2 <- -0.198
 start.list$mean.2.1 <- 0.293
 start.list$mean.2.2 <- -0.198
 start.list$sqrt.sd <- sqrt( 0.640 ) ## sqrt.sd is the sqrt of the standard deviation.

 ## "start.level" is ignored when you indicate "start" argument.
 result <- a$nls.freq( df, this.kind = 14, start.level = 1, start = start.list )
 result$start.level  ## NA
 plot.freq.and.d( a, df$x, df$freq )

 ## When you call the nls.freq method of a GGD object consecutively,
 ## the conditions in the fields are retained (if no error has occurred).
 a$nls.freq( df, grad = "hv", eq.mean = TRUE, start.level = 2 )
 a$mix.type; a$is.eq.mean()  ## 4; TRUE
 plot.freq.and.d( a, df$x, df$freq )

 a$nls.freq( df, eq.mean = FALSE, start.level = 2 )   ## grad = "hv" is retained.
 a$mix.type; a$is.eq.mean()  ## 4; FALSE
 plot.freq.and.d( a, df$x, df$freq )

 ## Using "x.2" for x and "freq.2" for freq.
 b <- ggd.nls.freq( df, x = "x.2", freq = "freq.2", start.level = 2 )$obj
 b
 plot.freq.and.d( b, df$x.2, df$freq.2 )
}
\seealso{
\code{\link[stats]{nls}}, \code{\link[stats]{nls.control}},
         \code{\link[ggd]{ggd.nls.freq.all}}, \code{\link[ggd]{ggd.start.template}}
}
