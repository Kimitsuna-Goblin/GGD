% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ggd.nls.freq.R
\name{nls.freq}
\alias{nls.freq}
\alias{ggd.nls.freq}
\alias{\S4method{nls.freq}{GGD}}
\title{Approximating a frequency distribution}
\usage{
ggd.nls.freq(data, x = "x", freq = "freq", total = NULL,
         kind = NULL, mix.type = NULL,
         grad = c("default", "normal", "h", "v", "v2", "v3", "hv"),
         eq.mean = logical(), eq.sd = logical(),
         start.level = 100, start = NULL, control = list(),
         not.use.nls = FALSE, cor.method = NULL, ...)

\S4method{nls.freq}{GGD}(data, x = "x", freq = "freq", total = NULL,
         this.kind = NULL, this.mix.type = NULL,
         grad = c("default", "normal", "h", "v", "v2", "v3", "hv"),
         eq.mean = logical(), eq.sd = logical(),
         start.level = 100, start = NULL, control = list(),
         not.use.nls = FALSE, cor.method = NULL, ...)
}
\arguments{
\item{data}{A data frame which represents the frequency distribution.
                     It must contain at least 2 numeric columns for \code{x} and \code{freq}.

                     Column \bold{\code{x}} is for the x-coordinates.
                     Each value is expected to be a numeric value which represents a cell of
                     the frequency distribution
                     as the x-coordinate at the center of the cell.
                     The values must be arranged in ascending order, and not be duplicated.

                     Column \bold{\code{freq}} is for the frequencies following \code{x}.
                     The values of frequencies should not be negative.
                     Both integers and real numbers are allowed for the values.

                     Rows which contain \code{NA} or \code{NaN} for \code{x} or \code{freq}
                     are ignored. For fine approximation, the number of rows should be
                     large enough; it is recommended that there are more than 8 valid rows.

                     Column names and column numbers for \code{x} and \code{freq}
                     are flexible. You can indicate them with next two arguments.}

\item{x}{The column name or column number for x-coordinates in \code{data}.}

\item{freq}{The column name or column number for frequencies in \code{data}.}

\item{total}{Total value of the frequencies.

                     If \code{NULL} (the default),
                     the total of \code{freq}, i.e., \code{\link[base]{sum}(data[[freq]])}
                     (on \code{\link[stats]{complete.cases}} of \code{x} and \code{freq})
                     is used for it.}

\item{kind}{A character string or a numeric value or a \code{\link[ggd]{GGD}} object
                     which indicates the kind of distribution model to be generated.
                     The matching method of \code{kind} follows that of
                     \code{objs} argument of \code{\link[ggd]{ggd.kind.index}}.

                     This argument gives the conditions of
                     the value of \code{mix.type} field,
                     and of whether the mean values or standard deviations of the components
                     should be aligned to the same value or not.

                     Indicating \code{mix.type} or \code{grad} other than \code{"default"},
                     or \code{eq.mean} and \code{eq.sd} other than \code{logical(0)}
                     can overwrite the condition of this argument.}

\item{mix.type}{A numeric value to set into \code{mix.type} field of
                     the \code{\link[ggd]{GGD}} object as an integer.
                     It should be an integer from \code{0} to \code{4} or \code{NULL}.

                     The type of the distribution model will be as:
                     \itemize{
                         \item 0: Normal distribution.
                         \item 1: Mean of 2 normal distributions.
                         \item 2: Horizontal gradation of 2 normal distributions.
                         \item 3: Vertical gradation of 2 (or 3) normal distributions.
                         \item 4: Horizontal-vertical gradation
                                  with 4 (2x2) normal distributions.
                     }

                     Where \code{mix.type = 3} is indicated,
                     \code{ggd.nls.freq} function generates a 2-component model.
                     If you want to generate a 3-component model, use \code{grad = "v3"}.

                     If other than \code{"default"} for \code{grad} argument is indicated,
                     this argument will be ignored.}

\item{grad}{A character string indicating the method of gradation.

                     \code{"h"} for horizontal, \code{"v"} for vertical,
                     and \code{"hv"} for horizontal-vertical.
                     The number after \code{"v"} is the number of components.
                     Numberless \code{"v"} is an alias for \code{"v2"}.

                     \code{"normal"} is for a normal distribution.
                     \code{"default"} is for depending on values of other arguments.

                     If other than \code{"default"} is indicated,
                     this function will create a \code{\link[ggd]{GGD}} object
                     according to this argument with ignoring \code{[this.]mix.type} argument
                     and overwriting the type indicated by \code{[this.]kind} argument.}

\item{eq.mean}{A logical. If \code{TRUE}, all of the mean values of of the components
                     are forced to be equal.

                     If \code{FALSE} or \code{logical(0)},
                     the mean values are not bound,
                     and mean-equaled components will be rarely constructed.

                     \code{TRUE} and \code{FALSE} can overwrite the condition indicated by
                     \code{kind} or \code{this.kind} argument.}

\item{eq.sd}{A logical. If \code{TRUE}, all of the standard deviations of
                     the components are forced to be equal.

                     If \code{FALSE} or \code{logical(0)},
                     the standard deviations are not bound,
                     and sigma-equaled components will be rarely constructed.

                     If both \code{eq.mean} and \code{eq.sd} are \code{TRUE},
                     a normal distribution will be constructed.

                     \code{TRUE} and \code{FALSE} can overwrite the condition indicated by
                     \code{kind} or \code{this.kind} argument.}

\item{start.level}{A numeric value of integer in from \code{0} to \code{3} or \code{100}
                     with default \code{100}; the level of initial guessing
                     for \code{start} argument of \code{\link[stats]{nls}}.

         The detail of each level is:
         \itemize{
             \item \code{0}:
                      The mean and the standard deviation of the frequency distribution
                      are used as the start values.
             \item \code{1}:
                      In addition to level \code{0}, it computes the local mean values
                      and local standard deviations of the frequency distribution
                      in ranges of x-coordinates where the effect of each of components is
                      likely to be heavy, and uses them for guessing the start values
                      if they are likely to be better guesses.
             \item \code{2}:
                      In addition to level \code{0}, at first it computes some quantiles
                      from the frequency distribution, then it finds normal distributions
                      tracing two of the quantiles, and uses the mean values and
                      standard deviations of them for guessing the start values
                      if they are likely to be better guesses.
             \item \code{3}:
                      It generates a \code{\link[ggd]{GGD}} object tracing
                      some (2, 3 or 5) quantiles computed from the frequency distribution,
                      and uses the mean values and standard deviations of the components
                      of the object as the start values.
                      If the generating fails, level \code{2} is used instead.
             \item \code{100}:
                      Try all of above levels and adopt the result of the highest
                      \code{\link[stats]{cor}} value.
         }

         As the level increases within the range of \code{0} to \code{3},
         the initial model will tend to be closer to the frequency distribution.
         However, the accuracy of the result may not along with the level.
         It is possible that \code{\link[stats]{nls}} will succeed at level \code{1}
         and fail at level \code{3} for the same data.}

\item{start}{A list for \code{start} argument of \code{\link[stats]{nls}}.

                     You can provide your own \code{start} for \code{\link[stats]{nls}},
                     the mean values (parameters are like: \code{mean}, \code{mean.i},
                     or \code{mean.i.j})
                     and the \bold{square root} of the standard deviations
                     (parameters are like: \code{sqrt.sd}, \code{sqrt.sd.i},
                     or \code{sqrt.sd.i.j}) of the normal distributions of the components.

                     Depending on the kind of the distribution model,
                     the names of the parameters are different.
                     You can use \code{\link[ggd]{ggd.start.template}}
                     to get the template of the list and know the names of the parameters.

                     If a not-\code{NULL} list is indicated for this argument,
                     \code{start.level} argument is ignored.}

\item{control}{The list for \code{control} argument of \code{\link[stats]{nls}}.
See \code{\link[stats]{nls.control}} for more information.}

\item{not.use.nls}{A logical.
                     If \code{TRUE}, this function does not use \code{\link[stats]{nls}} and
                     it outputs an object having the start values in \code{cmp} field
                     as the result.
                     If \code{FALSE}, this function uses \code{\link[stats]{nls}}.

                     This argument works when \code{start.level} argument is
                     other than \code{100}. A warning will occur if \code{TRUE}
                     when \code{start.level} is \code{100}.

                     You can use \code{not.use.nls = TRUE} to check
                     whether the start values are appropriate
                     when you have obtained an undesirable result from this function.}

\item{cor.method}{The \code{method} argument for \code{\link[stats]{cor}}.
It is a character string indicating which correlation coefficient
(or covariance) is to be computed in order to compare the results
between levels when \code{start.level = 100}.
If \code{NULL}, it uses the default method of \code{\link[stats]{cor}}.
This argument works only if \code{start.level = 100}.
See \code{\link[stats]{cor}} for more information.}

\item{...}{Each argument for \code{\link[stats]{nls}} can be indicated.
See \sQuote{Arguments} of \code{\link[stats]{nls}} for more information.}

\item{this.kind}{A character string or a numeric value or a \code{\link[ggd]{GGD}} object
                     which indicates the kind of distribution model to be constructed.
                     It is equivalent to \code{kind} argument of \code{ggd.nls.freq}.

                     When this method is called without \code{this.kind} argument
                     or other conditions, it attempts to retain the value of
                     \code{mix.type} field as much as possible, but not \code{kind} field.
                     That is, the condition that the mean values or standard deviations
                     of the components are aligned to the same values or not
                     may not be retained. If you want to retain the condition as well,
                     indicate the object itself to \code{this.kind} argument like as
                     \code{obj$nls.freq(data, this.kind = obj)}.}

\item{this.mix.type}{A numeric value to set into \code{mix.type} field as an integer.
                         It is equivalent to \code{mix.type} argument of
                         \code{ggd.nls.freq}.

                     Where \code{this.mix.type = 3} is indicated,
                     \code{nls.freq} method constructs 2- or 3- component model
                     according to the number of current components.

                     If both of \code{this.kind} and \code{this.mix.type} are not given
                     and \code{grad} argument is \code{"default"},
                     the current value of \code{mix.type} field will be retained,
                     and number of components will also.
                     However, if the object has been cleared when this method is called,
                     \code{mix.type} field will be \code{2}, the start value.}
}
\value{
A list containing components (invisible for \code{GGD} method)
         \item{obj}{
                 Generated \code{\link[ggd]{GGD}} object which most (at least locally)
                 closely approximates the given frequency distribution.
                 If \code{\link[stats]{nls}} has failed, it will be a cleared object.
                 For \code{\link[ggd]{GGD}} method,
                 the \code{\link[ggd]{GGD}} object itself.}
         \item{nls.out}{
                 The list of the output of \code{\link[stats]{nls}}.
                 If \code{\link[stats]{nls}} has not been used, \code{NULL} will be set.
                 See \sQuote{Value} of \code{\link[stats]{nls}} for more information.}
         \item{start.level}{
                 The initial guessing level which is used actually to obtain \code{obj}.
                 If \code{start.level = 100} is indicated,
                 the level for the best result will be set.
                 When \code{start.level = 3} is indicated
                 and if initial guessing has failed, \code{2} will be set.
                 If you indicate \code{start} argument a not-\code{NULL} list,
                 \code{start.level} will be \code{NA}.}
         \item{start}{
                 The used \code{start} argument of \code{\link[stats]{nls}}.}
         \item{start.obj}{
                 A \code{\link[ggd]{GGD}} object corresponding to the start values.
                 That is, a \code{\link[ggd]{GGD}} object in which
                 values of the above \code{start} are set directly to \code{cmp} field.}
         \item{cor}{
                 The vector of the correlation coefficient of between the result for
                 each initial guessing level in the range of \code{0} to \code{3}
                 and the frequency distribution.
                 This component is given only if \code{start.level = 100}.}
         \item{errors}{
                 A list of information about errors occurred in \code{\link[stats]{nls}}.
                 This component is given only if \code{start.level = 100}.
                 Each element in the list contains:
                 \itemize{
                     \item level: The initial guessing level when the error has occurred.
                     \item message: The error message.
                 }}
         \item{warnings}{
                 A list of information about warnings occurred in \code{\link[stats]{nls}}.
                 This component is given only if \code{start.level = 100}.
                 The composition of each element is same as \code{errors}.}

         For \code{GGD} method: If an error occurs, all fields of the object will be cleared
                                in most cases.
}
\description{
With the non-linear least squares (\code{\link[stats]{nls}}),
constructs a \code{\link[ggd]{GGD}} object which (locally) most closely approximates
the given frequency distribution.
Then \code{ggd.nls.freq} function generates a \code{\link[ggd]{GGD}} object,
and \code{nls.freq} method sets the fields according to the result.
\sQuote{Locally} means that if the start value is modified, more closely approximating model
may be constructed.
The outliers of the frequency distribution will not be excluded in this function.
If necessary, outliers should be excluded by preprocessing.
}
\details{
\subsection{Why the standard deviations for start are square-rooted?}{
     You know a standard deviation must be a positive value.
     But if you use standard deviations directly in the formula for \code{\link[stats]{nls}},
     they sometimes drop into negative values while the Gauss-Newton algorithm is running
     and the algorithm will fail, even if it can reach convergence if done better.

     Therefore, to avoid such failures, we use square roots of standard deviations and
     take squares of them in the formula for \code{\link[stats]{nls}}.
 }
}
\examples{
 ## Preparing:
 df <- data.frame(
             x      = seq( -2, 2, 0.2 ),
             freq   = c( 1517,  2292,  2513,  2763,  3724,  4046,  4713,
                         7947, 10997, 11824, 11133,  7868,  4692,  4103,
                         3698,  2740,  2549,  2284,  1499,  1147,   918 ),
             x.2    = seq( -20, 20, 2 ),
             freq.2 = c( .000974, .003797, .008523, .023142, .045017, .081743, .120990,
                         .142527, .124627, .106294, .078625, .059378, .045690, .042958,
                         .035760, .030938, .015675, .012516, .008139, .005114, .003582 ) )

 ## This function plots probability densities obtained from the frequency distribution
 ## and the probability density function of a GGD object.
 plot.freq.and.d <- function( obj, x, freq )
 {
     xlim <- c( min( x ), max( x ) )
     ylim <- c( 0, max( ggd:::get.d.freq( x, freq ) ) * 1.2 )
     plot( x, ggd:::get.d.freq( x, freq ), xlim = xlim, ylim = ylim, xlab = "", ylab = "" )
     par( new = TRUE )
     plot( seq( min( x ), max( x ), 0.01 ), obj$d( seq( min( x ), max( x ), 0.01 ) ),
           type = "l", xlim = xlim, ylim = ylim )
 }

 ## Examples:
 result <- ggd.nls.freq( df, mix.type = 0 )
 result
 plot.freq.and.d( result$obj, df$x, df$freq )

 ## You should not indicate 'start.level' to obtain good quality results,
 ## but it is indicated here to make the process faster.
 a <- GGD$new()
 a$nls.freq( df, this.kind = "2.*Sigma-Equaled Vertical", start.level = 2 )
 a
 plot.freq.and.d( a, df$x, df$freq )

 ## Overwriting 'Sigma-Differed' with 'eq.sd = FALSE' after 'kind = a'.
 b <- ggd.nls.freq( df, kind = a, eq.sd = FALSE, start.level = 2 )$obj
 a$kind; b$kind      ## "... Sigma-Equaled ..."; "... Sigma-Differed ..."
 plot.freq.and.d( b, df$x, df$freq )

 ## You can specify start values with 'start' argument.
 start.list <- ggd.start.template( 14 )
 start.list

 start.list$mean.1.1 <- -0.671
 start.list$mean.1.2 <- -0.198
 start.list$mean.2.1 <- 0.293
 start.list$mean.2.2 <- -0.198
 start.list$sqrt.sd <- sqrt( 0.640 ) ## 'sqrt.sd' is the sqrt of the standard deviation.

 ## You can check the start values with 'not.use.nls = TRUE' before approximating.
 a$nls.freq( df, this.kind = 14, start = start.list, not.use.nls = TRUE )
 a$cmp
 plot.freq.and.d( a, df$x, df$freq )

 ## When you indicate 'start' argument, 'start.level' argument is ignored.
 result <- a$nls.freq( df, this.kind = 14, start.level = 1, start = start.list )
 result$start.level      ## NA
 result$start.obj$cmp    ## Verify start values.
 a$cmp                   ## results
 plot.freq.and.d( a, df$x, df$freq )

 ## When you call nls.freq method of a GGD object consecutively,
 ## the conditions saved in the fields are retained (if no error has occurred).
 a$nls.freq( df, grad = "hv", eq.mean = TRUE, start.level = 2 )
 a$mix.type; a$is.eq.mean()  ## 4; TRUE
 plot.freq.and.d( a, df$x, df$freq )

 a$nls.freq( df, eq.mean = FALSE, start.level = 2 )   ## 'grad = "hv"' is retained.
 a$mix.type; a$is.eq.mean()  ## 4; FALSE
 plot.freq.and.d( a, df$x, df$freq )

 ## Using "x.2" for x and "freq.2" for freq.
 b <- ggd.nls.freq( df, x = "x.2", freq = "freq.2", start.level = 2 )$obj
 b
 plot.freq.and.d( b, df$x.2, df$freq.2 )

\dontrun{
 ## Using the default 'start.level' (100) is the best way to obtain a good quality result,
 ## but the process is slow to demonstrate as a running example. So, it is not run here.
 ##
 ## The following results written in comments are
 ## obtained on a Windows 11 64-bit environment using ggd v1.0.3 package.
 result <- a$nls.freq( df, grad = "v" )
 result$cor
 ##   level.0   level.1   level.2   level.3
 ## 0.9867103 0.9867102 0.9867103 0.9867102
 result$start.level
 ## 2
 a$cmp
 ##           mean       sd
 ## n.1 -0.1841741 1.039255
 ## n.2 -0.1973208 0.648003

 ## 'cor.method' argument is available for 'start.level = 100'
 ## but the default value is recommended (see 'Details' at the manual of cor).
 result <- a$nls.freq( df, cor.method = "kendall" )
 result$cor
 ##   level.0   level.1   level.2   level.3
 ## 0.9428571 0.9428571 0.9428571 0.9428571  ## All values were equal.
 result$start.level
 ## 0
 a$cmp
 ##           mean       sd
 ## n.1 -0.1841703 1.039255
 ## n.2 -0.1973202 0.648003

 ## 'start.level = 3' does not always generate good start values.
 ## This execution may cause an error in nls due to strange start values.
 a$nls.freq( df, grad = "hv", start.level = 3 )
 ## If run, an error may occur as: 'nls has failed. Message: Error in nls...'

 ## To get a result even if an error occurs in nls,
 ## you can indicate 'warnOnly = TRUE' in 'control' option.
 a$nls.freq( df, grad = "hv", start.level = 3, control = list( warnOnly = TRUE ) )
 ## If run, a warning may occur (a singular gradient).}
}
\seealso{
\code{\link[stats]{nls}}, \code{\link[stats]{nls.control}},
         \code{\link[ggd]{ggd.nls.freq.all}}, \code{\link[ggd]{ggd.start.template}}
}
