% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/GGD.R
\name{trace.q}
\alias{trace.q}
\alias{ggd.trace.q}
\alias{\S4method{trace.q}{GGD}}
\title{Quantile tracing}
\usage{
ggd.trace.q(quantiles, x = "x", p = "p",
         kind = NULL, mix.type = NULL,
         grad = c("default", "normal", "h", "v", "v2", "v3", "hv"),
         eq.mean = logical(), eq.sd = logical(), control = list())

\S4method{trace.q}{GGD}(quantiles, x = "x", p = "p",
         this.kind = NULL, this.mix.type = NULL,
         grad = c("default", "normal", "h", "v", "v2", "v3", "hv"),
         eq.mean = logical(), eq.sd = logical(), control = list())
}
\arguments{
\item{quantiles}{A data frame which represents the quantiles to be traced.

                     It must contain at least 2 numeric columns for \code{x} and \code{p}.
                     Column \bold{\code{x}} is for the x-coordinates,
                     and column \bold{\code{p}} is for the probabilities of the quantiles.

                     Rows which contain \code{NA} or \code{NaN} are ignored.
                     The value of each row must not duplicated
                     (except for \code{NA} or \code{NaN}),
                     and must be valid as a set of quantiles.
                     You do not have to sort the order of quantiles.
                     The number of valid rows must be in range of from 2 to 8.

                     A valid example:
                     \code{data.frame(x = c(0, -2, 2.3), p = c(0.5, 0.25, 0.75))}.

                     Column names and column numbers for \code{x} and \code{p} are flexible.
                     You can specify them with next two arguments.}

\item{x}{The column name or column number for x-coordinates in \code{quantiles}.}

\item{p}{The column name or column number for probabilities in \code{quantiles}.}

\item{kind}{A character string or a numeric value or a \code{\link[ggd]{GGD}} object
                     which indicates the kind of the distribution model.

                     The matching method of this argument follows that of elements of
                     the \code{objs} argument of the \link[ggd]{ggd.kind.index}.

                     This argument gives the conditions of
                     the value of \code{mix.type} field,
                     and of whether the mean values and standard deviations of the components
                     should be aligned to the same value.

                     Indicating \code{mix.type} argument or
                     indicating other than \code{"default"} for \code{grad} argument
                     or \code{TRUE}/\code{FALSE} for \code{eq.mean} or \code{eq.sd}
                     can overwrite the conditions of this argument.}

\item{mix.type}{A numeric value to set into \code{mix.type} field as an integer.
                     You can specify a value in \code{0:4} or \code{NULL}.

                     Each value represents the following type of distribution:
                     \itemize{
                         \item \code{0} : Normal distribution.
                         \item \code{1} : Mean of 2 normal distributions (not a GGD).
                         \item \code{2} : Horizontal gradation of 2 normal distributions.
                         \item \code{3} : Vertical gradation of 2 or 3 normal distributions.
                                          The 2-component model has priority.
                         \item \code{4} : Horizontal-Vertical gradation
                                          with 4 (2x2) normal distributions.
                     }
                     If \code{NULL} (and if \code{kind} and \code{grad = "default"}),
                     it tries to trace the quantiles with changing
                     the \code{mix.type} according to the priority sequence:
                     2 > 4 > 3 (2 components) > 3 (3 components) > 1 > 0.

                     If other than \code{"defaule"} for \code{grad} argument is indicated,
                     this argument will be ignored.}

\item{grad}{A character string indicating the method of gradation.

                     \code{"h"} for horizontal, \code{"v"} for vertical,
                     and \code{"hv"} for horizontal-vertical.
                     The number after \code{"v"} is the number of components.
                     Numberless \code{"v"} is an alias for \code{"v2"}.

                     \code{"normal"} is for a normal distribution.
                     \code{"default"} is for depending on other arguments.

                     If other than \code{"default"} is indicated,
                     this function constructs a distribution model
                     according to this argument with ignoring \code{[this.]mix.type} argument
                     and overwriting the type indicated by \code{[this.]kind} argument.}

\item{eq.mean}{A logical. It works when \code{mix.type} is not 0.

                     If \code{TRUE}, it forces all of the mean values of the components
                     to be equal.
                     This condition reduces the degrees of freedom,
                     so allowed number of quantiles will be restricted.
                     See "Details" for more information.

                     If \code{FALSE}, it constructs mean-differed components.
                     In this case, mean-equaled components are rarely constructed.

                     If \code{logical(0)} (the default),
                     Normally, as \code{FALSE}, it constructs mean-differed components.
                     But if that fails, it tries to construct mean-equaled components
                     as \code{TRUE} (especially, when the median is specified as a quantile
                     to trace with a vertical gradational distribution).

                     \code{TRUE} and \code{FALSE} can overwrite the condition indicated by
                     \code{kind} or \code{this.kind} argument.}

\item{eq.sd}{A logical. It works when \code{mix.type} is not 0.

                     If \code{TRUE}, it forces all of the standard deviations of
                     the components to be equal.
                     This condition reduces the degrees of freedom,
                     so allowed number of quantiles will be restricted.
                     See "Details" for more information.

                     If \code{FALSE} or \code{logical(0)},
                     it constructs sigma-differed components.
                     In this case, sigma-equaled components are rarely constructed.

                     \code{TRUE} and \code{FALSE} can overwrite the condition indicated by
                     \code{kind} or \code{this.kind} argument.}

\item{control}{A list of \code{control} option for \code{\link[nleqslv]{nleqslv}}.
                     See the "Control options" at \code{\link[nleqslv]{nleqslv}}
                     for more information.

                     By default, this list is empty, but if there is a high probability
                     of a "Jacobian is singular" error due to the condition of the quantiles,
                     \code{allowSingular = TRUE} is set implicitly.
                     However, if \code{allowSingular} is given to this argument,
                     the given option takes priority.}

\item{this.kind}{A string or a numeric value or a \code{\link[ggd]{GGD}} object
                     which indicates the kind of distribution model to construct.

                     This argument will work as same as \code{kind} argument
                     of the generator function (signature '\code{NULL}').

                     If this method is called without \code{this.kind} argument,
                     flags, or other conditions, it attempt to retain the value of
                     \code{mix.type} field as much as possible, but not the value of
                     \code{kind} field, i.e., the condition whether the mean value or
                     standard deviation of each component is aligned may not be retained.
                     If you want to retain the conditions as well,
                     indicate the object itself to \code{this.kind} argument like as
                     \code{obj$trace.q(quantiles, this.kind = obj)}.}

\item{this.mix.type}{A numeric value to set into \code{mix.type} field as an integer.
                         You can specify a value in \code{0:4} or \code{NULL}.

                     If \code{NULL}, the current \code{mix.type} field will be retained
                     (and number of components, too) if it could trace the quantiles.
                     But if could not, it tries to trace the quantiles
                     with changing \code{mix.type} as same as the generator function
                     (signature '\code{NULL}').
                     Thus, the priority sequence of \code{mix.type} is
                     current > 2 > 4 > 3 (2 components) > 3 (3 components) > 1 > 0.}
}
\value{
A list containing components (invisible for \code{GGD} method)
         \item{obj}{
                 The \code{\link[ggd]{GGD}} object which traces the quantiles.
                 For \code{\link[ggd]{GGD}} method, the \code{\link[ggd]{GGD}} object itself.}
         \item{nleqslv.out}{
                 The list of the output of \code{\link[nleqslv]{nleqslv}}
                 which has successed to solve tracing quantiles.}

         For \code{GGD} method: If an error occur, the object will be cleared in most cases.
}
\description{
Constructs a \code{\link[ggd]{GGD}} object which traces all of the given quantiles
accurately with its cumulative distribution function.
}
\details{
\subsection{Allowed number of quantiles}{
     The allowed numbers of quantiles depends on the value of \code{mix.type} argument/field.
     Because the value determines the number of components in \code{cmd} field,
     and resultingly determines the degrees of freedom of the distribution model.
     The allowed numbers of quantiles are as follows:
     \itemize{
         \item \code{mix.type = 0} : 2 quantiles only.
         \item \code{mix.type = 1} : 3 or 4 quantiles.
         \item \code{mix.type = 2} : 3 or 4 quantiles.
         \item \code{mix.type = 3} : 3 to 6 quantiles.
         \item \code{mix.type = 4} : 5 to 8 quantiles.
     }
     About \code{mix.type = 3},
     if \code{grad = "v2"}, 3 or 4 quantiles are allowed.
     If \code{grad = "v3"}, 3 to 6 quantiles are allowed.

     Note, if \code{mix.type = 3} is indicated with \code{grad = "default"},
     it tries both \code{grad = "v2"} and \code{"v3"} cases
     and give priority to \code{"v2"}.
 }
 \subsection{Tightening with eq.mean / eq.sd}{
     If either \code{eq.mean = TRUE} or \code{eq.sd = TRUE} is indicated,
     as each of them reduces the degrees of freedom,
     the number of quantiles is restricted as follows:
     \itemize{
         \item \code{mix.type = 1} : 3 quantiles only.
         \item \code{mix.type = 2} : 3 quantiles only.
         \item \code{mix.type = 3} : 3 or 4 quantiles.
         \item \code{mix.type = 4} : 5 quantiles only.
     }
     About \code{mix.type = 3},
     with \code{grad = "v2"}, it works for 3 quantiles only.
     With \code{grad = "v3"}, it works for 3 or 4 quantiles.

     If both \code{eq.mean} and \code{eq.sd} are \code{TRUE},
     a normal distribution will be constructed and number of quantiles must be 2.
 }
}
\examples{
 ## Mean of 2 Normal Distributions Example:
 ##  If mix.type = 1, it constructs a mean of 2 normal distributions.
 ##  This model is not a gradational Gaussian distribution (GDD),
 ##  but a kind of Gaussian mixture model (GMM).
 ##  The number of quantiles must be 3 or 4.
 result <- ggd.trace.q( data.frame(
                        x = c( qnorm( 0.1, 0, 1 ), 0, qnorm( 0.6, 0, 0.75 ) ),
                        p = c( 0.1, 0.5, 0.6 ) ),
                        mix.type = 1 )
 result
 plot( seq( -3, 3, 0.01 ), result$obj$d( seq( -3, 3, 0.01 ) ), type = "l" )

 ## Horizontal Gradational Example:
 ##  If mix.type = 2 or grad = "h",
 ##  it constructs a horizontal gradational distribution.
 ##  The number of p of the quantiles must be 3 or 4.
 a$trace.q(
     data.frame( x = c( -0.67, 0, 0.53 ), p = c( 0.25, 0.5, 0.75 ) ),
     this.mix.type = 2 )
 a
 plot( seq( -3, 3, 0.01 ), a$d( seq( -3, 3, 0.01 ) ), type = "l" )

 ## eq.sd Example:
 ##  If eq.sd = TRUE, it constructs a distribution model with components of which
 ##  the standard deviations are all equal.
 a$trace.q(
         data.frame( x = c( -0.64, -0.25, 0 ), p = c( 0.25, 0.4, 0.5 ) ),
         this.mix.type = 2, eq.sd = TRUE )
 a$cmp
 plot( seq( -3, 3, 0.01 ), a$d( seq( -3, 3, 0.01 ) ), type = "l" )

 ## Vertical Gradational Example:
 ##  If grad = "v2", it constructs a vertical gradation of 2 normal distributions.
 ##  The number of quantiles must be 3 or 4.
 a$trace.q(
         data.frame( x = c( -1.28, -0.23, 0 ), p = c( 0.1, 0.4, 0.5 ) ),
         grad = "v2" )
 plot( seq( -3, 3, 0.01 ), a$d( seq( -3, 3, 0.01 ) ), type = "l" )

 ## eq.mean Example:
 ##  If eq.mean = TRUE, it constructs a mean-equaled distribution model.

 a$trace.q(
         data.frame( x = c( -1.28, -0.42, 0 ), p = c( 0.1, 0.3, 0.5 ) ),
         grad = "v2", eq.mean = TRUE )
 a$cmp
 plot( seq( -3, 3, 0.01 ), a$d( seq( -3, 3, 0.01 ) ), type = "l" )

 ## 3-Mean/Sigma-Differed Vertical Gradational Example:
 ##  If grad = "v3", it constructs a vertical gradational distribution
 ##  with different components for left-tail side and right-tail side.
 ##  The number of quantiles must be from 3 to 6.
 a <- ggd.trace.q(
         data.frame( x = c( -1.92, -0.20, 0.20, 1.92 ), p = c( 0.1, 0.4, 0.6, 0.9 ) ),
         grad = "v3" )$obj
 a
 plot( seq( -3, 3, 0.01 ), a$d( seq( -3, 3, 0.01 ) ), type = "l" )

 ## Horizontal-Vertical Gradational Examples:
 ##  If mix.type = 4 or grad = "hv",
 ##  it constructs a horizontal-vertical gradational distribution.
 ##  The number of quantiles must be from 5 to 8.
 a <- ggd.trace.q(
         data.frame(
             x = c( -1.38, -0.76, -0.28, 0.02, 0.36, 1.10, 2.79 ),
             p = c( 0.1, 0.25, 0.4, 0.5, 0.6, 0.75, 0.9 ) ),
         mix.type = 4 )$obj
 a
 plot( seq( -3, 3, 0.01 ), a$d( seq( -3, 3, 0.01 ) ), type = "l" )

 a$trace.q(
     data.frame(
         x = c( -1.40, -0.96, -0.61, -0.30, 0.32, 0.72, 1.23, 2.21 ),
         p = c( 0.1, 0.2, 0.3, 0.4, 0.6, 0.7, 0.8, 0.9 ) ),
     grad = "hv" )
 a
 plot( seq( -3, 3, 0.01 ), a$d( seq( -3, 3, 0.01 ) ), type = "l" )
}
\seealso{
\code{\link[ggd]{nls.freq}}
}
