% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ggd.trace.q.R
\name{trace.q}
\alias{trace.q}
\alias{ggd.trace.q}
\alias{\S4method{trace.q}{GGD}}
\title{Quantile tracing}
\usage{
ggd.trace.q(quantiles, x = "x", p = "p",
         kind = NULL, mix.type = NULL,
         grad = c("default", "normal", "h", "v", "v2", "v3", "hv"),
         eq.mean = logical(), eq.sd = logical(), control = list())

\S4method{trace.q}{GGD}(quantiles, x = "x", p = "p",
         this.kind = NULL, this.mix.type = NULL,
         grad = c("default", "normal", "h", "v", "v2", "v3", "hv"),
         eq.mean = logical(), eq.sd = logical(), control = list())
}
\arguments{
\item{quantiles}{A data frame which represents the quantiles to be traced.

                     It must contain at least 2 numeric columns for \code{x} and \code{p}.
                     Column \bold{\code{x}} is for the x-coordinates,
                     and column \bold{\code{p}} is for the probabilities of the quantiles.

                     Rows which contain \code{NA} or \code{NaN} are ignored.
                     The set of complete cases must be valid as a set of quantiles
                     and each row of them must not be duplicated.
                     You do not have to sort the order of quantiles.
                     The number of valid rows must be in range of from 2 to 8.

                     A valid example:
                     \code{data.frame(x = c(0, -2, 2.3), p = c(0.5, 0.25, 0.75))}.

                     Column names and column numbers for \code{x} and \code{p} are flexible.
                     You can indicate them with next two arguments.}

\item{x}{The column name or column number for x-coordinates in \code{quantiles}.}

\item{p}{The column name or column number for probabilities in \code{quantiles}.}

\item{kind}{A character string or a numeric value or a \code{\link[ggd]{GGD}} object
                     which indicates the kind of distribution model to be generated.
                     The matching method of \code{kind} follows that of
                     \code{objs} argument of \code{\link[ggd]{ggd.kind.index}}.

                     This argument gives the conditions of
                     the value of \code{mix.type} field,
                     and of whether the mean values or standard deviations of the components
                     should be aligned to the same value.

                     Indicating \code{mix.type} or \code{grad} other than \code{"default"},
                     or \code{eq.mean} and \code{eq.sd} other than \code{logical(0)}
                     can overwrite the condition of this argument.}

\item{mix.type}{A numeric value to set into \code{mix.type} field as an integer.
                     It should be an integer from \code{0} to \code{4} or \code{NULL}.

                     Each value represents the following type of distribution:
                     \itemize{
                         \item \code{0} : Normal distribution.
                         \item \code{1} : Mean of 2 normal distributions.
                         \item \code{2} : Horizontal gradation of 2 normal distributions.
                         \item \code{3} : Vertical gradation of 2 or 3 normal distributions.
                                          The 2-component model has priority.
                         \item \code{4} : Horizontal-vertical gradation
                                          with 4 (2x2) normal distributions.
                     }
                     If \code{NULL}
                     (and \code{kind} is also \code{NULL}, and \code{grad = "default"}),
                     it tries to trace the quantiles with changing
                     \code{mix.type} according to the priority sequence:
                     2 > 4 > 3 (2 components > 3 components) > 1 > 0.

                     If \code{grad} argument other than \code{"default"} is indicated,
                     this argument will be ignored.}

\item{grad}{A character string indicating the method of gradation.

                     \code{"h"} for horizontal, \code{"v"} for vertical,
                     and \code{"hv"} for horizontal-vertical.
                     The number after \code{"v"} is the number of components.
                     Numberless \code{"v"} is an alias for \code{"v2"}.

                     \code{"normal"} is for a normal distribution.
                     \code{"default"} is for depending on other arguments.

                     If other than \code{"default"} is indicated,
                     this function ignores \code{[this.]mix.type} argument
                     and overwrites the condition indicated by \code{[this.]kind} argument.}

\item{eq.mean}{A logical. It works when \code{mix.type} is other than \code{0}.

                     If \code{TRUE}, it forces all of the mean values of the components
                     to be equal.
                     This condition reduces the degrees of freedom,
                     so allowed number of quantiles will be restricted.
                     See 'Details' for more information.

                     If \code{FALSE}, the mean values are not bound,
                     and mean-equaled components will be rarely constructed.

                     If \code{logical(0)} (the default),
                     Normally, the mean values are not bound same as \code{FALSE}.
                     But if it has failed to trace without binding,
                     it tries to trace with binding mean values as \code{TRUE}.
                     In some cases, reducing degrees of freedom helps to reach convergence.

                     \code{TRUE} and \code{FALSE} can overwrite the condition indicated by
                     \code{[this.]kind} argument.}

\item{eq.sd}{A logical. It works when \code{mix.type} is other than \code{0}.

                     If \code{TRUE}, it forces all of the standard deviations of
                     the components to be equal.
                     This condition reduces the degrees of freedom,
                     so allowed number of quantiles will be restricted.
                     See 'Details' for more information.

                     If \code{FALSE} or \code{logical(0)},
                     the standard deviations are not bound,
                     and sigma-equaled components will be rarely constructed.

                     \code{TRUE} and \code{FALSE} can overwrite the condition indicated by
                     \code{[this.]kind} argument.}

\item{control}{A list of \code{control} option for \code{\link[nleqslv]{nleqslv}}.
                     See the "Control options" at \code{\link[nleqslv]{nleqslv}}
                     for more information.

                     By default, this list is empty normally.
                     But if the convergence appears to be difficult due to
                     an insufficient number of quantiles compared to the degrees of freedom,
                     \code{allowSingular = TRUE} is set implicitly.
                     If \code{allowSingular} is given to this argument,
                     the given value takes priority.}

\item{this.kind}{A character string or a numeric value or a \code{\link[ggd]{GGD}} object
                     which indicates the kind of distribution model to be constructed.
                     It is equivalent to \code{kind} argument of \code{ggd.trace.q}.

                     In this method, the value of \code{kind} field will be not
                     necessarily retained without indicating any conditions,
                     whereas the value of \code{mix.type} field will be retained
                     as long as possible.
                     That is, the condition of aligning the mean values or
                     standard deviations of the component to be equal will not be retained.
                     If you want to retain the condition as well,
                     indicate the object itself to \code{this.kind} argument like as
                     \code{obj$trace.q(quantiles, this.kind = obj)}.}

\item{this.mix.type}{A numeric value to set into \code{mix.type} field as an integer.
                         It should be an integer from \code{0} to \code{4} or \code{NULL}.
                         It is equivalent to \code{mix.type} argument of \code{ggd.trace.q}.

                     If \code{NULL}, the current \code{mix.type} field will be retained
                     (and number of components, too) if it can trace the quantiles.
                     But if could not, it tries to trace the quantiles
                     with changing \code{mix.type} as same as \code{ggd.trace.q}.
                     The priority sequence of \code{mix.type} is
                     current > 2 > 4 > 3 (2 components > 3 components) > 1 > 0.}
}
\value{
A list containing components (invisible for \code{GGD} method)
         \item{obj}{
                 The \code{\link[ggd]{GGD}} object which traces the quantiles.
                 For \code{\link[ggd]{GGD}} method,
                 the \code{\link[ggd]{GGD}} object itself.}
         \item{nleqslv.out}{
                 The list of the output of \code{\link[nleqslv]{nleqslv}}
                 which has succeeded to solve tracing quantiles.}

         For \code{GGD} method: If an error occurs, all fields
                                (except \code{custom.d} and \code{custom.p})
                                of the object will be cleared in most cases.
}
\description{
Constructs a \code{\link[ggd]{GGD}} object which traces all of the given quantiles
accurately with its cumulative distribution function.
Then \code{ggd.trace.q} function generates a \code{\link[ggd]{GGD}} object,
and \code{trace.q} method sets the fields according to the result.
}
\details{
\subsection{Allowed number of quantiles}{
     The allowed numbers of quantiles depends on the value of \code{mix.type}.
     Because \code{mix.type} determines the number of components in \code{cmd} field,
     and the degrees of freedom follows it.
     In this package, the allowed numbers of quantiles are:
     \itemize{
         \item \code{mix.type = 0} : 2 quantiles only.
         \item \code{mix.type = 1} : 3 or 4 quantiles.
         \item \code{mix.type = 2} : 3 or 4 quantiles.
         \item \code{mix.type = 3} : 3 to 6 quantiles.
         \item \code{mix.type = 4} : 5 to 8 quantiles.
     }
     About \code{mix.type = 3},
     if \code{grad = "v2"}, only 3 or 4 quantiles are allowed.
     If \code{grad = "v3"}, 3 to 6 quantiles are allowed.
     If \code{grad = "default"} is indicated with \code{mix.type = 3},
     it tries both \code{grad = "v2"} and \code{"v3"} cases
     with giving priority to \code{"v2"}.
 }
 \subsection{Tightening with eq.mean / eq.sd}{
     Indicating \code{TRUE} for either \code{eq.mean} or \code{eq.sd}
     reduces the degrees of freedom.
     In this case, the number of quantiles is restricted as:
     \itemize{
         \item \code{mix.type = 1} : 3 quantiles only.
         \item \code{mix.type = 2} : 3 quantiles only.
         \item \code{mix.type = 3} : 3 or 4 quantiles.
         \item \code{mix.type = 4} : 5 quantiles only.
     }
     About \code{mix.type = 3},
     with \code{grad = "v2"}, it works for 3 quantiles only.
     With \code{grad = "v3"}, it works for 3 or 4 quantiles.

     If both \code{eq.mean} and \code{eq.sd} are \code{TRUE},
     a normal distribution will be generated.
     In this case, number of quantiles must be 2.
 }
}
\examples{
 ## Preparing:
 ## This function shows 1) the cumulative distribution function with plotting the quantiles
 ## and 2) the probability density function.
 plot.p.qt.d <- function( obj, x, p, xlim, ylim )
 {
     layout( matrix( c( 1, 0, 2, 0 ), 2, 2, byrow = TRUE ) )
     plot( x, p, xlim = xlim, ylim = c( 0, 1 ), xlab = "", ylab = "" )
     par( new = TRUE )
     plot( seq( xlim[1], xlim[2], 0.1 ), obj$p( seq( xlim[1], xlim[2], 0.1 ) ),
           type = "l", xlim = xlim, ylim = c( 0, 1 ), xlab = "", ylab = "" )
     par( new = FALSE )
     plot( seq( xlim[1], xlim[2], 0.1 ), obj$d( seq( xlim[1], xlim[2], 0.1 ) ),
           type = "l", xlim = xlim, ylim = ylim, xlab = "", ylab = "" )
 }

 ## Horizontal gradation:
 ##  If mix.type = 2 or grad = "h", it generates a horizontal gradational distribution.
 ##  The number of quantiles must be 3 or 4.
 qt <- data.frame( x = c( -0.67, 0, 0.53 ), p = c( 0.25, 0.5, 0.75 ) )
 result <- ggd.trace.q( qt, mix.type = 2 )
 result
 plot.p.qt.d( result$obj, qt$x, qt$p, c( -3, 3 ), c( 0, 0.5 ) )

 ## 2-component vertical gradation:
 ##  If grad = "v" or "v2", it generates a 2-component vertical gradational distribution.
 ##  The number of quantiles must be 3 or 4.
 qt <- data.frame( x.1 = c( -1.28, -0.42, 0 ), x.2 = c( -1.14, -0.51, 0 ),
                   p = c( 0.1, 0.3, 0.5 ) )
 a <- GGD$new()
 a$trace.q( qt, x = "x.1", grad = "v2" )
 a$kind; a$cmp; a$is.symmetric() ## FALSE
 plot.p.qt.d( a, qt$x.1, qt$p, c( -3, 3 ), c( 0, 0.52 ) )

 ## eq.mean:
 ##  If eq.mean = TRUE, it generates a mean-equaled distribution model.
 a$trace.q( qt, x = "x.1", eq.mean = TRUE )
 a$kind; a$cmp; a$is.symmetric() ## TRUE
 plot.p.qt.d( a, qt$x.1, qt$p, c( -3, 3 ), c( 0, 0.52 ) )

 ## eq.sd:
 ##  If eq.sd = TRUE, it generates a distribution model with components of which
 ##  the standard deviations are all equal.
 a$trace.q( qt, x = "x.2", this.kind = "Horizontal", eq.sd = TRUE )
 a$kind; a$cmp; a$is.symmetric() ## TRUE
 plot.p.qt.d( a, qt$x.2, qt$p, c( -3, 3 ), c( 0, 0.4 ) )

 ## 3-component vertical gradation:
 ##  If grad = "v3", it generates a vertical gradational distribution
 ##  with different components for left-tail side and right-tail side.
 ##  The number of quantiles must be from 3 to 6.
 qt <- data.frame( x = c( -1.92, -0.20, 0.20, 1.92 ), p = c( 0.1, 0.4, 0.6, 0.9 ) )
 a$trace.q( qt, grad = "v3" )
 a$kind; a$cmp
 plot.p.qt.d( a, qt$x, qt$p, c( -3, 3 ), c( 0, 0.52 ) )

 ## Horizontal-vertical gradation:
 ##  If mix.type = 4 or grad = "hv",
 ##  it generates a horizontal-vertical gradational distribution.
 ##  The number of quantiles must be from 5 to 8.
 qt <- data.frame( x.coor = c( -1.40, -0.96, -0.61, -0.30, 0.32, 0.72, 1.23, 2.21 ),
                   prob   = c( 0.1, 0.2, 0.3, 0.4, 0.6, 0.7, 0.8, 0.9 ) )
 a$trace.q( qt, x = "x.coor", p = "prob", grad = "hv" )
 a$kind; a$cmp
 plot.p.qt.d( a, qt$x, qt$p, c( -3, 3 ), c( 0, 0.35 ) )
}
\seealso{
\code{\link[ggd]{nls.freq}}
}
