% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ggd.trace.q.R
\name{trace.q}
\alias{trace.q}
\alias{ggd.trace.q}
\alias{\S4method{trace.q}{GGD}}
\title{Quantile tracing}
\usage{
ggd.trace.q(quantiles, x = "x", p = "p",
         kind = NULL, mix.type = NULL,
         grad = c("default", "normal", "h", "v", "v2", "v3", "hv"),
         eq.mean = logical(), eq.sd = logical(), control = list())

\S4method{trace.q}{GGD}(quantiles, x = "x", p = "p",
         this.kind = NULL, this.mix.type = NULL,
         grad = c("default", "normal", "h", "v", "v2", "v3", "hv"),
         eq.mean = logical(), eq.sd = logical(), control = list())
}
\arguments{
\item{quantiles}{A data frame which represents the quantiles to be traced.

                     It must contain at least 2 numeric columns for \code{x} and \code{p}.
                     Column \bold{\code{x}} is for the x-coordinates,
                     and column \bold{\code{p}} is for the probabilities of the quantiles.

                     Rows which contain \code{NA} or \code{NaN} are ignored.
                     The set of complete cases must be valid as a set of quantiles
                     and each row of them must not be duplicated.
                     You do not have to sort the order of quantiles.
                     The number of valid rows must be in range of from 2 to 8.

                     A valid example:
                     \code{data.frame(x = c(0, -2, 2.3), p = c(0.5, 0.25, 0.75))}.

                     Column names and column numbers for \code{x} and \code{p} are flexible.
                     You can indicate them with next two arguments.}

\item{x}{The column name or column number for x-coordinates in \code{quantiles}.}

\item{p}{The column name or column number for probabilities in \code{quantiles}.}

\item{kind}{A character string or a numeric value or a \code{\link[ggd]{GGD}} object
                     which indicates the kind of distribution model to be generated.
                     The matching method of \code{kind} follows that of
                     \code{objs} argument of \code{\link[ggd]{ggd.kind.index}}.

                     This argument gives the conditions of
                     the value of \code{mix.type} field,
                     and of whether the mean values or standard deviations of the components
                     should be aligned to the same value.

                     Indicating \code{mix.type} or \code{grad} other than \code{"default"},
                     or \code{eq.mean} and \code{eq.sd} other than \code{logical(0)}
                     can overwrite the condition of this argument.}

\item{mix.type}{A numeric value to set into \code{mix.type} field as an integer.
                     It should be an integer from \code{0} to \code{4} or \code{NULL}.

                     Each value represents the following type of distribution:
                     \itemize{
                         \item \code{0} : Normal distribution.
                         \item \code{1} : Mean of 2 normal distributions.
                         \item \code{2} : Horizontal gradation of 2 normal distributions.
                         \item \code{3} : Vertical gradation of 2 or 3 normal distributions.
                                          The 2-component model has priority.
                         \item \code{4} : Horizontal-Vertical gradation
                                          with 4 (2x2) normal distributions.
                     }
                     If \code{NULL}
                     (and \code{kind} is also \code{NULL}, and \code{grad = "default"}),
                     it tries to trace the quantiles with changing
                     \code{mix.type} according to the priority sequence:
                     2 > 4 > 3 (2 components > 3 components) > 1 > 0.

                     If \code{grad} argument other than \code{"default"} is indicated,
                     this argument will be ignored.}

\item{grad}{A character string indicating the method of gradation.

                     \code{"h"} for horizontal, \code{"v"} for vertical,
                     and \code{"hv"} for horizontal-vertical.
                     The number after \code{"v"} is the number of components.
                     Numberless \code{"v"} is an alias for \code{"v2"}.

                     \code{"normal"} is for a normal distribution.
                     \code{"default"} is for depending on other arguments.

                     If other than \code{"default"} is indicated,
                     this function ignores \code{[this.]mix.type} argument
                     and overwrites the condition indicated by \code{[this.]kind} argument.}

\item{eq.mean}{A logical. It works when \code{mix.type} is other than \code{0}.

                     If \code{TRUE}, it forces all of the mean values of the components
                     to be equal.
                     This condition reduces the degrees of freedom,
                     so allowed number of quantiles will be restricted.
                     See "Details" for more information.

                     If \code{FALSE}, the mean values are not bound,
                     and mean-equaled components will be rarely constructed.

                     If \code{logical(0)} (the default),
                     Normally, the mean values are not bound same as \code{FALSE}.
                     But if it has failed to trace without binding,
                     it tries to trace with binding mean values as \code{TRUE}.
                     In some cases, reducing degrees of freedom helps to reach convergence.

                     \code{TRUE} and \code{FALSE} can overwrite the condition indicated by
                     \code{[this.]kind} argument.}

\item{eq.sd}{A logical. It works when \code{mix.type} is other than \code{0}.

                     If \code{TRUE}, it forces all of the standard deviations of
                     the components to be equal.
                     This condition reduces the degrees of freedom,
                     so allowed number of quantiles will be restricted.
                     See "Details" for more information.

                     If \code{FALSE} or \code{logical(0)},
                     the standard deviations are not bound,
                     and sigma-equaled components will be rarely constructed.

                     \code{TRUE} and \code{FALSE} can overwrite the condition indicated by
                     \code{[this.]kind} argument.}

\item{control}{A list of \code{control} option for \code{\link[nleqslv]{nleqslv}}.
                     See the "Control options" at \code{\link[nleqslv]{nleqslv}}
                     for more information.

                     By default, this list is empty normally.
                     But if the convergence appears to be difficult due to
                     an insufficient number of quantiles compared to the degrees of freedom,
                     \code{allowSingular = TRUE} is set implicitly.
                     If \code{allowSingular} is given to this argument,
                     the given value takes priority.}

\item{this.kind}{A character string or a numeric value or a \code{\link[ggd]{GGD}} object
                     which indicates the kind of distribution model to be constructed.
                     It is equivalent to \code{kind} argument for \code{ggd.trace.q}.

                     In this method, the value of \code{kind} field will be not
                     necessarily retained without indicating any conditions,
                     whereas the value of \code{mix.type} field will be retained
                     as long as possible.
                     That is, the condition of aligning the mean values or
                     standard deviations of the component to be equal will not be retained.
                     If you want to retain the condition as well,
                     indicate the object itself to \code{this.kind} argument like as
                     \code{obj$trace.q(quantiles, this.kind = obj)}.}

\item{this.mix.type}{A numeric value to set into \code{mix.type} field as an integer.
                         It should be an integer from \code{0} to \code{4} or \code{NULL}.
                         It is equivalent to \code{mix.type} argument for \code{ggd.trace.q}.

                     If \code{NULL}, the current \code{mix.type} field will be retained
                     (and number of components, too) if it can trace the quantiles.
                     But if could not, it tries to trace the quantiles
                     with changing \code{mix.type} as same as \code{ggd.trace.q}.
                     The priority sequence of \code{mix.type} is
                     current > 2 > 4 > 3 (2 components > 3 components) > 1 > 0.}
}
\value{
A list containing components (invisible for \code{GGD} method)
         \item{obj}{
                 The \code{\link[ggd]{GGD}} object which traces the quantiles.
                 For \code{\link[ggd]{GGD}} method,
                 the \code{\link[ggd]{GGD}} object itself.}
         \item{nleqslv.out}{
                 The list of the output of \code{\link[nleqslv]{nleqslv}}
                 which has succeeded to solve tracing quantiles.}

         For \code{GGD} method: If an error occurs, all fields of the object will be cleared
                                in most cases.
}
\description{
Constructs a \code{\link[ggd]{GGD}} object which traces all of the given quantiles
accurately with its cumulative distribution function.
Then \code{ggd.trace.q} function generates a \code{\link[ggd]{GGD}} object,
and \code{trace.q} method sets the fields according to the result.
}
\details{
\subsection{Allowed number of quantiles}{
     The allowed numbers of quantiles depends on the value of \code{mix.type}.
     Because \code{mix.type} determines the number of components in \code{cmd} field,
     and the degrees of freedom follows it.
     In this package, the allowed numbers of quantiles are:
     \itemize{
         \item \code{mix.type = 0} : 2 quantiles only.
         \item \code{mix.type = 1} : 3 or 4 quantiles.
         \item \code{mix.type = 2} : 3 or 4 quantiles.
         \item \code{mix.type = 3} : 3 to 6 quantiles.
         \item \code{mix.type = 4} : 5 to 8 quantiles.
     }
     About \code{mix.type = 3},
     if \code{grad = "v2"}, only 3 or 4 quantiles are allowed.
     If \code{grad = "v3"}, 3 to 6 quantiles are allowed.
     If \code{grad = "default"} is indicated with code{mix.type = 3},
     it tries both \code{grad = "v2"} and \code{"v3"} cases
     with giving priority to \code{"v2"}.
 }
 \subsection{Tightening with eq.mean / eq.sd}{
     Indicating \code{TRUE} for either \code{eq.mean} or \code{eq.sd}
     reduces the degrees of freedom.
     In this case, the number of quantiles is restricted as:
     \itemize{
         \item \code{mix.type = 1} : 3 quantiles only.
         \item \code{mix.type = 2} : 3 quantiles only.
         \item \code{mix.type = 3} : 3 or 4 quantiles.
         \item \code{mix.type = 4} : 5 quantiles only.
     }
     About \code{mix.type = 3},
     with \code{grad = "v2"}, it works for 3 quantiles only.
     With \code{grad = "v3"}, it works for 3 or 4 quantiles.

     If both \code{eq.mean} and \code{eq.sd} are \code{TRUE},
     a normal distribution will be generated.
     In this case, number of quantiles must be 2.
 }
}
\examples{
 ## Mean of 2 Normal Distributions Example:
 ##  If mix.type = 1, it generates a mean of 2 normal distributions.
 ##  This model is not a gradational Gaussian distribution (GDD),
 ##  but a kind of Gaussian mixture model (GMM).
 ##  The number of quantiles must be 3 or 4.
 result <- ggd.trace.q( data.frame(
                        x = c( qnorm( 0.1, 0, 1 ), 0, qnorm( 0.6, 0, 0.75 ) ),
                        p = c( 0.1, 0.5, 0.6 ) ),
                        mix.type = 1 )
 result
 plot( seq( -3, 3, 0.01 ), result$obj$d( seq( -3, 3, 0.01 ) ), type = "l" )

 ## Horizontal Gradational Example:
 ##  If mix.type = 2 or grad = "h",
 ##  it generates a horizontal gradational distribution.
 ##  The number of p of the quantiles must be 3 or 4.
 a <- ggd.trace.q( data.frame( x = c( -0.67, 0, 0.53 ), p = c( 0.25, 0.5, 0.75 ) ),
                   mix.type = 2 )$obj
 a
 plot( seq( -3, 3, 0.01 ), a$d( seq( -3, 3, 0.01 ) ), type = "l" )

 ## eq.sd Example:
 ##  If eq.sd = TRUE, it generates a distribution model with components of which
 ##  the standard deviations are all equal.
 a$trace.q(
         data.frame( x = c( -0.64, -0.25, 0 ), p = c( 0.25, 0.4, 0.5 ) ),
         this.mix.type = 2, eq.sd = TRUE )
 a$cmp
 plot( seq( -3, 3, 0.01 ), a$d( seq( -3, 3, 0.01 ) ), type = "l" )

 ## Vertical Gradational Example:
 ##  If grad = "v2", it generates a vertical gradation of 2 normal distributions.
 ##  The number of quantiles must be 3 or 4.
 a$trace.q(
         data.frame( x = c( -1.28, -0.23, 0 ), p = c( 0.1, 0.4, 0.5 ) ),
         grad = "v2" )
 plot( seq( -3, 3, 0.01 ), a$d( seq( -3, 3, 0.01 ) ), type = "l" )

 ## eq.mean Example:
 ##  If eq.mean = TRUE, it generates a mean-equaled distribution model.

 a$trace.q(
         data.frame( x = c( -1.28, -0.42, 0 ), p = c( 0.1, 0.3, 0.5 ) ),
         grad = "v2", eq.mean = TRUE )
 a$cmp
 plot( seq( -3, 3, 0.01 ), a$d( seq( -3, 3, 0.01 ) ), type = "l" )

 ## 3-Mean/Sigma-Differed Vertical Gradational Example:
 ##  If grad = "v3", it generates a vertical gradational distribution
 ##  with different components for left-tail side and right-tail side.
 ##  The number of quantiles must be from 3 to 6.
 a <- ggd.trace.q(
         data.frame( x = c( -1.92, -0.20, 0.20, 1.92 ), p = c( 0.1, 0.4, 0.6, 0.9 ) ),
         grad = "v3" )$obj
 a
 plot( seq( -3, 3, 0.01 ), a$d( seq( -3, 3, 0.01 ) ), type = "l" )

 ## Horizontal-Vertical Gradational Examples:
 ##  If mix.type = 4 or grad = "hv",
 ##  it generates a horizontal-vertical gradational distribution.
 ##  The number of quantiles must be from 5 to 8.
 a <- ggd.trace.q(
         data.frame(
             x = c( -1.38, -0.76, -0.28, 0.02, 0.36, 1.10, 2.79 ),
             p = c( 0.1, 0.25, 0.4, 0.5, 0.6, 0.75, 0.9 ) ),
         mix.type = 4 )$obj
 a
 plot( seq( -3, 3, 0.01 ), a$d( seq( -3, 3, 0.01 ) ), type = "l" )

 a$trace.q(
     data.frame(
         x = c( -1.40, -0.96, -0.61, -0.30, 0.32, 0.72, 1.23, 2.21 ),
         p = c( 0.1, 0.2, 0.3, 0.4, 0.6, 0.7, 0.8, 0.9 ) ),
     grad = "hv" )
 a
 plot( seq( -3, 3, 0.01 ), a$d( seq( -3, 3, 0.01 ) ), type = "l" )
}
\seealso{
\code{\link[ggd]{nls.freq}}
}
